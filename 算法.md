# 整点算法  
 开始学算法了，鉴于以往的经验，这次不仅要自己动手写，更要做笔记记录下来。 

## 排序算法
### 归并

归并的原理是将两有序数组合并，在“并”的同时进行判断的“归”操作。在此基础上运用到递归的方法，不断二分数组，直至数组内仅包含单一元素，再不断向上合并，合并时就可看作两有序数组。如此反复，直到排序整个数组。  
因为js里有很多操作数组的简便方法，所以写起来并不难，理解起来也没太大问题，主要是熟悉下递归思想。
```JavaScript
//归并算法#1 合成有序列表
function merge(arr, arr2) {
    let ans = new Array()       //这里每次调用都创建新数组影响效率，可以初始化创建一个与传入数组长度相等的数组替代
    let m = 0
    let n = 0
    while (true) {
        if (m == arr.length) {
            return [...ans, ...(arr2.splice(n))]
        }
        else if (n == arr2.length) {
            return [...ans, ...(arr.splice(m))]
        }
        else if (arr[m] <= arr2[n]) {
            ans.push(arr[m])
            m++
        } else {
            ans.push(arr2[n])
            n++
        }
    }
}
```
```JavaScript
//归并#2 二分递归
function mergesort(arr, start, end) {
    if (start >= end) { return [arr[start]] }
    
    let mid = parseInt((start + end) / 2)   //二分
 
    let left = mergesort(arr, start, mid)   //左域
    let right = mergesort(arr, mid + 1, end)  //右域

    return merge(left, right)
}
```
### 快排  

在尝试一种很新的东西。  

快速排序的外层依然是递归思想，但排序原理截然不同，归并通过由底向上的合并，最后形成有序排列的数组，快速排序则是通过规定<b>基数（pivot）</b>，每轮循环以基数为轴调换多个逆序对，最后完成排序。在每次循环还能固定下基数的位置，平均时间复杂度是O(nlogn)。 
```javascript
//快排#1
function quick(arr, start, end) {
    let pivot = arr[start]  //取首为基数
    let left = start + 1
    let right = end
    while (left < right) {
        while (left < right && arr[left] <= pivot) left++
        // 找到第一个小于基数的位置
        while (left < right && arr[right] >= pivot) right--
        // 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数
        if (left < right) {
            [arr[left], arr[right]] = [arr[right], arr[left]]
            left++
            right--
        }
    }
    if (left == right && arr[right] > pivot) right--
    // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot
    [arr[start], arr[right]] = [arr[right], arr[start]];
    // 返回中间值的下标
    return right;
}
``` 
从这里看其实外层结构和归并差不多，可能这就是递归思想（？）
```javascript
//快速排序#2
function quicksort(arr, start, end) {
    if (start >= end) return

    let mid = quick(arr, start, end)
    quicksort(arr, start, mid-1)
    quicksort(arr, mid + 1, end)
}
```
